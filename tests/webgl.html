<!DOCTYPE html>
<head>
	<title>Test of sprites in WebGL</title>
	<style>
	body { background: #eee; }
	.holder { position: relative; }
	canvas { border: 1px solid #444; position: relative; }
	.icon { display: inline-block; line-height: 0; cursor: pointer; line-height: 1.5em; padding: 0.5em; }
	.icon > svg { width: 1.5em; height: 1.5em; background: white; }
	.icon.label { padding: 0.5em; }
	.icon > * { filter: grayscale(1); opacity: 0.15; vertical-align: middle; }
	.icon.active > * { filter: none; opacity: 1; }
	.icon:hover { background-color: #ddd; }
	</style>
	<script src="webgl-helper.js"></script>
	<script src="webgl-debug.js"></script>
</head>
<body>
	<script>
	// Simulate log10(x) with log(x)/2.302585092994046
	gl = {'id':'canvas'};
	let shaders = {
		'symbol': {
			'vertex': {'src':`
				attribute vec2 aVertexPosition;	// position of sprite
				uniform mat3 uMatrix;
				uniform float uPointSize;
				uniform bool uYLog;
				uniform float uYLogMin;
				uniform float uYLogMax;
				vec2 posV;
				//float range;
				float log10(float v){
					return log(v)/2.302585092994046;
				}

				void main() {
					posV = (uMatrix * vec3(aVertexPosition, 1)).xy;
					if(uYLog){
						//range = uYLogMax - uYLogMin;
						//if(posV.y > 0.0) posV.y = log10(posV.y)/range;
						//else posV.y = -2.0;
					}
					gl_Position = vec4(posV, 0.1, 1);
					gl_PointSize = uPointSize;
				}`
			},
			'fragment':	{'src':`
				#ifdef GL_ES
				precision highp float;
				#endif
				uniform sampler2D uTexture;	// texture we are drawing
				void main() {
					gl_FragColor = texture2D(uTexture, gl_PointCoord);
				}`
			}
		},
		'line': {
			'vertex': {'src':`
				attribute vec2 aVertexPosition;	// position of vertex
				attribute vec2 aNormalPosition;	// position of normal
				uniform mat3 uMatrix;
				uniform bool uYLog;
				uniform float uYLogMin;
				uniform float uYLogMax;
				uniform float u_linewidth;
				uniform vec2 uSize;
				uniform int u_type;
				float scale_x;
				float scale_y;
				vec2 posV;
				vec2 posN;

				void main() {
					// Convert line width to final coords space in x and y
					scale_x = u_linewidth / uSize.x;
					scale_y = u_linewidth / uSize.y;

					posV = (uMatrix * vec3(aVertexPosition, 1)).xy;
					posN = aNormalPosition;
					if(u_type==1){
						posV.x = (aVertexPosition.x==0.0) ? -1.0 : 1.0;
					}else if(u_type==2){
						posV.y = (aVertexPosition.y==0.0) ? -1.0 : 1.0;
					}
					gl_Position = vec4(posV.x + posN.x * scale_x, posV.y + posN.y * scale_y, 1.0, 1);
				}`
			},
			'fragment':	{'src':`
				#ifdef GL_ES
				precision highp float;
				#endif
				uniform vec4 uStrokeColor;
				void main(void) {
					gl_FragColor = uStrokeColor;
				}`
			}
		},
		'area': {
			'vertex': {'src':`
				attribute vec2 aVertexPosition;	// position of vertex
				uniform mat3 uMatrix;
				uniform bool uYLog;
				uniform float uYLogMin;
				uniform float uYLogMax;
				vec2 posV;

				void main() {
					posV = (uMatrix * vec3(aVertexPosition, 1)).xy;
					gl_Position = vec4(posV, 1.0, 1);
				}`
			},
			'fragment':	{'src':`
				#ifdef GL_ES
				precision highp float;
				#endif
				uniform vec4 uFillColor;
				void main(void) {
					gl_FragColor = uFillColor;
				}`
			}
		},
		'rect': {
			'vertex': {'src':`
				attribute vec2 aVertexPosition;	// position of vertex
				uniform mat3 uMatrix;
				uniform bool uYLog;
				uniform float uYLogMin;
				uniform float uYLogMax;
				vec2 posV;

				void main() {
					posV = (uMatrix * vec3(aVertexPosition, 1)).xy;
					gl_Position = vec4(posV, 0, 1);
					gl_Position.z = 0.04;
				}`
			},
			'fragment':	{'src':`
				#ifdef GL_ES
				precision highp float;
				#endif
				uniform vec4 uFillColor;
				uniform vec4 uStrokeColor;
				uniform float uStrokeWidth;
				uniform vec2 uResolution;
				void main() {
//					vec2 st = gl_FragCoord.xy/uResolution;
//					vec2 thick = vec2(uStrokeWidth,0.04);
//					vec2 halfthick = thick/2.0;
//					vec3 a = vec3(0.6,0.4,0.0);
//					vec3 b = vec3(0.63,0.7,0.0);
					gl_FragColor = uFillColor;
//					if(st.x > a.x-halfthick.x && st.x < b.x+halfthick.x && st.y > a.y-halfthick.y && st.y < b.y+halfthick.y){
//						gl_FragColor = vec4(1.0,1.0,0.0,1.0);
//					}
				}`
			}
		}
	}

	let range = { 'x': {'min':0,'max':10}, 'y': {'min':0,'max':10} };
	var numperlayer = 100;

	function makeCurve(n){
		var data = new Array(n);
		var len = 8;
		var std = 0.25;
		var A = 4;
		var xo = len/2;
		for(i = 0; i < n; i++){
			x = len * ((i - n/2) / n);
			dx = x*len;
			data[i] = {'x':x+(len/2),'y':A*(dx != 0 ? Math.sin(dx)/(dx) : 1)+1.0};
		}
		return data;
	}

	function makeData(n){
		var data = new Array(n);
		for(var i = 0; i < n; i++){
			data[i] = {'x':Math.random()*(range.x.max-range.x.min) + range.x.min,'y':Math.random()*(range.y.max-range.y.min) + range.y.min};
		}
		return data;
	}

	let layers = [{
		'type': 'area',
		'shader': 'area',
		'data': [{'x':0,'y1':0.5,'y2':1.0},{'x':1,'y1':1.0,'y2':1.5},{'x':2,'y1':0.9,'y2':1.3},{'x':3,'y1':1.2,'y2':1.6},{'x':null,'y1':null,'y2':null},{'x':6.0,'y1':1.3,'y2':1.8},{'x':8.0,'y1':1.2,'y2':1.9},{'x':9.0,'y1':0.7,'y2':1.5}],
		'style': {'fillStyle':'rgba(55,55,55,0.5)'}
	},{
		'type': 'rule',
		'shader': 'line',
		'data': [{'x':0,'y':1},{'x':1.0,'y':1}],
		'style': {'strokeStyle':'rgb(0,255,0)','strokeWidth':10,'type':'fullWidth'}
	},{
		'type': 'rule',
		'shader': 'line',
		'data': [{'x':1.0,'y':0.0},{'x':1.0,'y':1.0}],
		'style': {'strokeStyle':'rgb(0,0,255)','strokeWidth':5,'type':'fullHeight'}
	},{
		'type': 'rule',
		'shader': 'line',
		'data': [{'x':2.0,'y':1.0},{'x':2.0,'y':5.0}],
		'style': {'strokeStyle':'rgb(255,0,0)','strokeWidth':4}
	},{
		'type': 'rule',
		'shader': 'line',
		'data': [{'x':3,'y':5.0},{'x':5,'y':5.0}],
		'style': {'strokeStyle':'rgb(0,0,0)','strokeWidth':1}
	},{
		'type': 'rule',
		'shader': 'line',
		'data': [{'x':0,'y':0.0},{'x':1,'y':0.0}],
		'style': {'strokeStyle':'rgb(255,255,0)','strokeWidth':4,'type':'fullWidth'}
	},{
		'type': 'rule',
		'shader': 'line',
		'data': [{'x':0,'y':0.0},{'x':0,'y':1.0}],
		'style': {'strokeStyle':'rgb(255,255,20)','strokeWidth':4,'type':'fullHeight'}
	},{
		'size': 16,
		'type': 'symbol',
		'shader': 'symbol',
		'shape': 'cross',
		'data': makeData(numperlayer),
		'style': {'strokeWidth':2,'strokeStyle':'#f68d69','fillStyle':'#f04031'}
	},{
		'size': 16,
		'type': 'symbol',
		'shader': 'symbol',
		'shape': 'arrow',
		'data': makeData(numperlayer),
		'style': {'fillStyle':'#4f4c9a'}
	},{
		'size': 16,
		'type': 'symbol',
		'shader': 'symbol',
		'shape': 'square',
		'data': makeData(numperlayer),
		'style': {'fillStyle':'#662d8f'}
	},{
		'size': 16,
		'type': 'symbol',
		'shader': 'symbol',
		'shape': 'triangle-up',
		'data': makeData(numperlayer),
		'style': {'strokeWidth':1,'strokeStyle':'rgb(0,0,0)','fillStyle':'#02a24b'}
	},{
		'size': 16,
		'type': 'symbol',
		'shader': 'symbol',
		'shape': 'triangle-left',
		'data': makeData(numperlayer),
		'style': {'strokeWidth':1,'strokeStyle':'rgb(0,0,0)','fillStyle':'#57b7aa'}
	},{
		'size': 16,
		'type': 'symbol',
		'shader': 'symbol',
		'shape': 'triangle-right',
		'data': makeData(numperlayer),
		'style': {'fillStyle':'#00a2d3'}
	},{
		'size': 16,
		'type': 'symbol',
		'shader': 'symbol',
		'shape': 'triangle-down',
		'data': makeData(numperlayer),
		'style': {'fillStyle':'rgba(23, 140, 255, 0.6)'}
	},{
		'size': 16,
		'type': 'symbol',
		'shader': 'symbol',
		'shape': 'circle',
		'data': makeData(numperlayer),
		'style': {'strokeWidth':1,'strokeStyle':'rgba(0,0,0,1)','fillStyle':'rgba(214, 3, 3, 1)'}
	},{
		'size': 2,
		'type': 'symbol',
		'shader': 'symbol',
		'shape': 'circle',
		'data': makeData(numperlayer),
		'style': {'fillStyle':'rgb(0, 0, 0)'}
	},{
		'size': 16,
		'type': 'symbol',
		'shader': 'symbol',
		'shape': 'stroke',
		'data': makeData(numperlayer),
		'style': {'strokeWidth':3,'strokeStyle':'rgb(239, 58, 171)'}
	},{
		'size': 16,
		'type': 'symbol',
		'shader': 'symbol',
		'shape': 'diamond',
		'data': makeData(numperlayer),
		'style': {'fillStyle':'rgba(249, 188, 38, 1)'}
	},{
		'size': 16,
		'type': 'symbol',
		'shader': 'symbol',
		'shape': 'wedge',
		'data': makeData(numperlayer),
		'style': {'fillStyle':'#b72268'}
	},{
		'size': 16,
		'type': 'symbol',
		'shader': 'symbol',
		'data': makeData(numperlayer),
		'shape': 'M0,.5L.6,.8L.5,.1L1,-.3L.3,-.4L0,-1L-.3,-.4L-1,-.3L-.5,.1L-.6,.8L0,.5Z',
		'style': {'strokeWidth':0,'strokeStyle':'rgba(255, 103, 0,0.5)','fillStyle':'rgba(249,188,38,1)'}
	},{
		'type': 'line',
		'shader': 'line',
		'data': makeCurve(1000),
		'style': {'strokeStyle':'rgb(255,0,255)','strokeWidth':2}
	}/*,{
		'type': 'rect',
		'style': {'strokeWidth':0,'strokeStyle':'rgba(255, 103, 0,0.5)','fillStyle':'rgba(249,188,38,1)'}
	}*/];

	// Coordinate system details
	let currentScale = [10, 10];
	let currentTranslation = [0,0];

	// Rendering data shared with the scalers.
	let aVertexPosition;

	// Animation timing
	window.addEventListener("load", startup, false);
	var log = new Logger({'id':'Timeseries','logging':true,'logtime':true});

	let cindex = 0;

	function getRGBA(c,a){
		a = (a||1.0);
		var rgb;
		if(c.indexOf("rgb")==0) c.replace(/rgba?\(([0-9]+),([0-9]+),([0-9]+),?([0-9\.]+)?/,function(m,p1,p2,p3,p4){ rgb = [parseInt(p1)/255,parseInt(p2)/255,parseInt(p3)/255,(parseFloat(p4)||a)]; return ""; });
		else if(c.indexOf('#')==0) rgb =[parseInt(c.substr(1,2),16)/255,parseInt(c.substr(3,2),16)/255,parseInt(c.substr(5,2),16)/255,a];
		return rgb;
	}

	function multiplyMatrixAndPoint(matrix, point) {

		//Give a simple variable name to each part of the matrix, a column and row number
		var c0r0 = matrix[0], c1r0 = matrix[1], c2r0 = matrix[2];
		var c0r1 = matrix[3], c1r1 = matrix[4], c2r1 = matrix[5];
		var c0r2 = matrix[6], c1r2 = matrix[7], c2r2 = matrix[8];

		//Now set some simple names for the point
		var x = point[0];
		var y = point[1];
		var z = point[2];

		//Multiply the point against each part of the 1st column, then add together
		var resultX = (x * c0r0) + (y * c0r1) + (z * c0r2);

		//Multiply the point against each part of the 2nd column, then add together
		var resultY = (x * c1r0) + (y * c1r1) + (z * c1r2);

		//Multiply the point against each part of the 3rd column, then add together
		var resultZ = (x * c2r0) + (y * c2r1) + (z * c2r2);

		return [resultX, resultY, resultZ];
	}

	function multiplyMatrices(matrixA, matrixB) {

		// Slice the second matrix up into columns
		var column0 = [matrixB[0], matrixB[3], matrixB[6]];
		var column1 = [matrixB[1], matrixB[4], matrixB[7]];
		var column2 = [matrixB[2], matrixB[5], matrixB[8]];

		// Multiply each column by the matrix
		var result0 = multiplyMatrixAndPoint(matrixA, column0);
		var result1 = multiplyMatrixAndPoint(matrixA, column1);
		var result2 = multiplyMatrixAndPoint(matrixA, column2);

		// Turn the result columns back into a single matrix
		return [
			result0[0], result1[0], result2[0],
			result0[1], result1[1], result2[1],
			result0[2], result1[2], result2[2]
		];
	}
	function makeIdentity() {
		return [
		1, 0, 0,
		0, 1, 0,
		0, 0, 1
		];
	}
	function makeTranslation(tx, ty) {
		return [
			1, 0, 0,
			0, 1, 0,
			tx, ty, 1
		];
	}
	function makeScale(sx, sy) {
		return [
			sx, 0, 0,
			0, sy, 0,
			0, 0, 1
		];
	}


	function drawScene(){

		log.time('drawScene');
		let scale = [currentScale[0],currentScale[1]];
		let fillColor = [255/255, 255/255, 0/255, 0.5];
		let strokeColor = [255/255, 0/255, 0/255, 0.5];
		let strokeWidth = 5.0;
		// Define the viewport area in pixels (x,y,w,h)
		gl.ctx.viewport(150, 100, gl.canvas.clientWidth-150-10, gl.canvas.clientHeight-100-10);
		gl.ctx.clearColor(0, 0, 0, 0);
		gl.ctx.clear(gl.ctx.COLOR_BUFFER_BIT | gl.ctx.DEPTH_BUFFER_BIT);
		gl.ctx.enable(gl.ctx.BLEND);
		gl.ctx.depthMask(false);

		// https://webglfundamentals.org/webgl/lessons/webgl-text-texture.html
		gl.ctx.blendFunc(gl.ctx.SRC_ALPHA, gl.ctx.ONE_MINUS_SRC_ALPHA);

		var matrix = makeIdentity();
		var scaleMatrix = makeScale(2/scale[0], 2/scale[1]);
		var translationMatrix = makeTranslation(currentTranslation[0], currentTranslation[1]);
		matrix = multiplyMatrices(matrix,translationMatrix);
		matrix = multiplyMatrices(matrix,scaleMatrix);
		matrix = multiplyMatrices(matrix,makeTranslation(-1, -1));

		for(var n = 0 ; n < layers.length; n++){
			if(!layers[n].hide){
				gl.ctx.useProgram(layers[n].program);
				t = layers[n].type;

				if(layers[n].loc.matrix) gl.ctx.uniformMatrix3fv(layers[n].loc.matrix, false, matrix);
				if(layers[n].loc.fillColor) gl.ctx.uniform4fv(layers[n].loc.fillColor, getRGBA(layers[n].style.fillStyle)||fillColor);
				if(layers[n].loc.strokeColor) gl.ctx.uniform4fv(layers[n].loc.strokeColor, getRGBA(layers[n].style.strokeStyle)||strokeColor);
				if(layers[n].loc.strokeWidth) gl.ctx.uniform1f(layers[n].loc.strokeWidth, (layers[n].style.strokeWidth||strokeWidth));
	//			gl.ctx.uniform1i(layers[n].loc.yLog, true);
	//			gl.ctx.uniform1f(layers[n].loc.yLogMin,-1.0);
	//			gl.ctx.uniform1f(layers[n].loc.yLogMax,1.2);
				if(t=="symbol"){
					gl.ctx.uniform1i(layers[n].loc.Texture, n,layers[n].style.strokeStyle);
					if(layers[n].size) gl.ctx.uniform1f(layers[n].loc.PointSize, layers[n].icon.width);
					gl.ctx.activeTexture(gl.ctx.TEXTURE0+n);	// this is the nth texture
				}

				// Only called when not initiated
				if(!layers[n].initiated && layers[n].vertex){
					// Set if this it is a logarithmic scale
					if(layers[n].loc.size) gl.ctx.uniform2fv(layers[n].loc.size, [gl.canvas.clientWidth,gl.canvas.clientHeight]);
					if(layers[n].loc.type) gl.ctx.uniform1i(layers[n].loc.type, (layers[n].style.type=="fullWidth" ? 1 : layers[n].style.type=="fullHeight" ? 2 : 0));


					gl.ctx.bindBuffer(gl.ctx.ARRAY_BUFFER, layers[n].buffer);
					aVertexPosition = gl.ctx.getAttribLocation(layers[n].program, "aVertexPosition");
					gl.ctx.vertexAttribPointer(aVertexPosition, layers[n].vertex.components, gl.ctx.FLOAT, false, 0, 0);
					gl.ctx.enableVertexAttribArray(aVertexPosition);
				
					if(t=="line" || t=="rule"){
						aNormalPosition = gl.ctx.getAttribLocation(layers[n].program, "aNormalPosition");
						gl.ctx.vertexAttribPointer(aNormalPosition, layers[n].vertex.components, gl.ctx.FLOAT, false, 0, layers[n].vertex.count * 8);
						gl.ctx.enableVertexAttribArray(aNormalPosition);
					}
					layers[n].inititated;
				}

				if(t=="symbol") gl.ctx.drawArrays(gl.ctx.POINTS, 0, layers[n].vertex.count);
				else if(t=="rect" || t=="area") gl.ctx.drawArrays(gl.ctx.TRIANGLES, 0, layers[n].vertex.count);
				else if(t=="line" || t=="rule") gl.ctx.drawArrays(gl.ctx.TRIANGLE_STRIP, 0, layers[n].vertex.count);
			}
		}
		log.time('drawScene');
	}

	function startup() {
		log.time('full');
		log.time('startup');

		gl.canvas = document.getElementById(gl.id);

		log.time('getContext webgl');
		function throwOnGLError(err, funcName, args) {
			throw WebGLDebugUtils.glEnumToString(err) + " was caused by call to: " + funcName;
		};
		function logAndValidate(functionName, args) {
			//logGLCall(functionName, args);
			//validateNoneOfTheArgsAreUndefined(functionName, args);
		}
		function logGLCall(functionName, args) {	 
			log.message("gl." + functionName + "(" + 
			WebGLDebugUtils.glFunctionArgsToString(functionName, args) + ")");	 
		}
		function validateNoneOfTheArgsAreUndefined(functionName, args) {
			for (var ii = 0; ii < args.length; ++ii) {
				if (args[ii] === undefined) {
					log.error("undefined passed to gl." + functionName + "(" +
					WebGLDebugUtils.glFunctionArgsToString(functionName, args) + ")");
				}
			}
		} 
		gl.ctx = WebGLDebugUtils.makeDebugContext(gl.canvas.getContext("webgl"),throwOnGLError,logAndValidate);
		log.time('getContext webgl');
		let s,n,i;

		log.time("buildShaders");
		for(t in shaders){
			for(s in shaders[t]) shaders[t][s].shader = compileShader(gl.ctx, s, shaders[t][s]);
		}
		log.time("buildShaders");

		log.time('buildLayers');
		for(n in layers){
			
			log.time("buildShaderProgram for "+n)
			layers[n].program = gl.ctx.createProgram();
			t = layers[n].type;
			st = layers[n].shader;
			for(s in shaders[st]){
				if(shaders[st][s].shader) gl.ctx.attachShader(layers[n].program, shaders[st][s].shader);
			}
			log.time("buildShaderProgram for "+n)

			log.time("linkProgram for "+n)
			gl.ctx.linkProgram(layers[n].program);
			if(!gl.ctx.getProgramParameter(layers[n].program, gl.ctx.LINK_STATUS)) {
				log.error("Error linking shader program:");
				log.message(gl.ctx.getProgramInfoLog(layers[n].program));
			}
			log.time("linkProgram for "+n)

			log.time('get locations');
			layers[n].loc = {};
			layers[n].loc.matrix = gl.ctx.getUniformLocation(layers[n].program, "uMatrix");
			layers[n].loc.yLog = gl.ctx.getUniformLocation(layers[n].program, "uYLog");
			layers[n].loc.yLogMin = gl.ctx.getUniformLocation(layers[n].program, "uYLogMin");
			layers[n].loc.yLogMax = gl.ctx.getUniformLocation(layers[n].program, "uYLogMax");
			if(t=="symbol"){
				layers[n].loc.Texture = gl.ctx.getUniformLocation(layers[n].program, "uTexture");
				if(layers[n].size) layers[n].loc.PointSize = gl.ctx.getUniformLocation(layers[n].program, "uPointSize");
			}else if(t=="line" || t=="rule"){
				layers[n].loc.strokeColor = gl.ctx.getUniformLocation(layers[n].program, "uStrokeColor");
				layers[n].loc.strokeWidth = gl.ctx.getUniformLocation(layers[n].program, "u_linewidth");
				layers[n].loc.size = gl.ctx.getUniformLocation(layers[n].program, "uSize");
				layers[n].loc.type = gl.ctx.getUniformLocation(layers[n].program, "u_type");
			}else if(t=="rect"){
				layers[n].loc.fillColor = gl.ctx.getUniformLocation(layers[n].program, "uFillColor");
				layers[n].loc.strokeColor = gl.ctx.getUniformLocation(layers[n].program, "uStrokeColor");
				layers[n].loc.strokeWidth = gl.ctx.getUniformLocation(layers[n].program, "uStrokeWidth");
			}else if(t=="area"){
				layers[n].loc.fillColor = gl.ctx.getUniformLocation(layers[n].program, "uFillColor");
			}
			log.time('get locations');

		}
		log.time('buildLayers');

		log.time('buffers');
		i = 0;
		for(n = 0; n < layers.length; n++){
			layers[n].buffer = gl.ctx.createBuffer();
			t = layers[n].type;
			gl.ctx.bindBuffer(gl.ctx.ARRAY_BUFFER, layers[n].buffer);
			if(t=="symbol"){
				layers[n].vertices = makePoints(layers[n].data);
				layers[n].vertex = { 'components': 2, 'count': layers[n].data.length/2 };
			}else if(t=="line" || t=="rule"){
				layers[n].vertices = makeLines(layers[n].data);
				layers[n].vertex = { 'components': 2, 'count': 4 * (layers[n].data.length - 1) };
			}else if(t=="area"){
				layers[n].vertices = makeAreas(layers[n].data);
				console.log(layers[n].vertices);
				layers[n].vertex = { 'components': 2, 'count':layers[n].vertices.length/2 };
			}else if(t=="rect"){
				layers[n].vertex = { 'components': 12, 'count':numperlayer };
				layers[n].vertices = new Float32Array(numperlayer*12);
				for(i = 0, j = 0; i < numperlayer; i++, j+=12){
					let x = (i/numperlayer)*(range.x.max-range.x.min) + range.x.min;
					let y = Math.random()*(range.y.max-range.y.min) + range.y.min;
					let dy = Math.random()*0.1;
					let dx = Math.random()*0.1;
					// Build point-based vertices
					let x1 = x-dx;
					let x2 = x+dx;
					let y1 = y-dy;
					let y2 = y+dy;
					layers[n].vertices[j] = [x1];
					layers[n].vertices[j + 1] = [y1];
					layers[n].vertices[j + 2] = [x2];
					layers[n].vertices[j + 3] = [y1];
					layers[n].vertices[j + 4] = [x1];
					layers[n].vertices[j + 5] = [y2];
					layers[n].vertices[j + 6] = [x1];
					layers[n].vertices[j + 7] = [y2];
					layers[n].vertices[j + 8] = [x2];
					layers[n].vertices[j + 9] = [y1];
					layers[n].vertices[j + 10] = [x2];
					layers[n].vertices[j + 11] = [y2];
				}
			}
			gl.ctx.bufferData(gl.ctx.ARRAY_BUFFER, layers[n].vertices, gl.ctx.STATIC_DRAW);
			// Unbind the buffer
			gl.ctx.bindBuffer(gl.ctx.ARRAY_BUFFER, null);
		}
		log.time('buffers');

		log.time('create icons and sprites');
		for(n = 0 ; n < layers.length; n++){
			let attr = layers[n].style;
			if(layers[n].type=="symbol"){
				attr.output = "texture";
				attr.size = layers[n].size;
				layers[n].icon = Icon(layers[n].shape||"circle",attr);
				layers[n].texture = gl.ctx.createTexture();
				gl.ctx.activeTexture(gl.ctx.TEXTURE0+n);	// this is the nth texture
				gl.ctx.bindTexture(gl.ctx.TEXTURE_2D, layers[n].texture);
				gl.ctx.pixelStorei(gl.ctx.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
				gl.ctx.texParameteri(gl.ctx.TEXTURE_2D, gl.ctx.TEXTURE_MAG_FILTER, gl.ctx.NEAREST);
				gl.ctx.texParameteri(gl.ctx.TEXTURE_2D, gl.ctx.TEXTURE_MIN_FILTER, gl.ctx.NEAREST);
				gl.ctx.texParameteri(gl.ctx.TEXTURE_2D, gl.ctx.TEXTURE_WRAP_S, gl.ctx.CLAMP_TO_EDGE);
				gl.ctx.texParameteri(gl.ctx.TEXTURE_2D, gl.ctx.TEXTURE_WRAP_T, gl.ctx.CLAMP_TO_EDGE);
				gl.ctx.texImage2D(gl.ctx.TEXTURE_2D, 0, gl.ctx.RGBA, gl.ctx.RGBA, gl.ctx.UNSIGNED_BYTE, layers[n].icon);

			}
			// Make SVG versions
			c = document.createElement('div');
			c.setAttribute('data',n);
			attr.output = "svg";
			attr.width = 32;
			attr.height = 32;

			if(layers[n].type=="symbol"){
				c.innerHTML = Icon(layers[n].shape||"circle",attr);
				c.setAttribute('class','icon active');
			}else if(layers[n].type=="area"){
				attr.size = attr.width;
				console.log(attr)
				c.innerHTML = Icon("square",attr)+' '+layers[n].type;
				c.setAttribute('class','icon active');
			}else{
				attr.size = attr.width;
				var orientation = "h";
				if(layers[n].style.type=="fullHeight") orientation = "v";
				if(layers[n].type=="rule" && layers[n].data[0].x==layers[n].data[1].x) orientation = "v";
				c.innerHTML = Icon((orientation=="h" ? "m-0.5,0 l 1,0" : "m0,-0.5 l 0,1"),attr)+' '+layers[n].type;
				c.setAttribute('class','icon active label');
			}
			c.addEventListener('click', function(){
				i = parseInt(this.getAttribute('data'));
				if(i < layers.length) layers[i].hide = !layers[i].hide;
				this.classList.toggle('active');
				console.log('test',this.getAttribute('data'));
				drawScene();
			});
			document.body.appendChild(c);
		}
		log.time('create icons and sprites');

		log.time('startup');

		drawScene();


		var cs = document.getElementById('canvas');
		cs.addEventListener('wheel',function(e){
			e.preventDefault();
			if(e.deltaY < 0){
				currentScale[0] /= 1.2;
				currentScale[1] /= 1.2;
			}else{
				currentScale[0] *= 1.2;
				currentScale[1] *= 1.2;
			}
			drawScene();
		})

		window.addEventListener('keydown',function(e){
			if(e.keyCode==37){
				e.preventDefault();
				currentTranslation[0] -= 0.01;
				cindex++;
				drawScene();
			}else if(e.keyCode==39){
				e.preventDefault();
				currentTranslation[0] += 0.01;
				cindex--;
				drawScene();
			}else if(e.keyCode==38){
				e.preventDefault();
				currentTranslation[1] += 0.01;
				drawScene();
			}else if(e.keyCode==40){
				e.preventDefault();
				currentTranslation[1] -= 0.01;
				drawScene();
			}
			i = parseInt(e.key);
			if(typeof i==="number"){
				if(i < layers.length) layers[i].hide = !layers[i].hide;
				drawScene();
			}else if(e.key == "a"){
				currentScale = [1/5,1/5];
				drawScene();
			}else if(e.key == "s"){
				currentScale = [1,1];
				drawScene();
			}else if(e.key == "d"){
				currentScale = [5,5];
				drawScene();
			}
		});

		log.time('full');
	}

	function makePoints(original){
		var vertices = new Float32Array(original.length*2);
		for(i = 0; i < original.length ; i++){
			// Build point-based vertices
			vertices[i*2] = original[i].x;
			vertices[i*2 + 1] = original[i].y;
		}
		return vertices;
	}

	function makeAreas(o){
		var areas = [];
		// We need to loop across the data first splitting into segments
		for(i = 0, a = 0; i < o.length ; i++){
			p = o[i];
			y1 = (typeof p.y1==="number" ? p.y1 : p.y);
			y2 = (typeof p.y2==="number" ? p.y2 : y1);
			if(!isNaN(p.x) && !isNaN(y1) && !isNaN(y2)){
				if(!areas[a]) areas[a] = [];
				areas[a].push(i);
			}else a++;
		}

		var vertices = [];
		
		// To do: make the polygon lookup processing more efficient by
		// not processing the entire shape in one go
		var poly = new Array(areas.length);
		for(a = 0; a < areas.length ; a++){
			if(areas[a] && areas[a].length){
				for(j = 0; j < areas[a].length-1; j++){
					p1 = o[areas[a][j]];
					p2 = o[areas[a][j+1]];
					vertices = vertices.concat([p1.x,p1.y2,p1.x,p1.y1,p2.x,p2.y1,p1.x,p1.y2,p2.x,p2.y2,p2.x,p2.y1]);
				}
			}
		}
		return new Float32Array(vertices);
	}
	
	function makeLines(original){
		// TR: compute normal vector
		var vertices = [];

		var o = new Array(original.length*2);
		for(i = 0; i < original.length;i++){
			o[i*2] = original[i].x;
			o[i*2 + 1] = original[i].y;
		}

		function normal_vector(dx, dy) {
			norm = (dx * dx + dy * dy) ** 0.5
			return -dy / norm, dx / norm
		}

		for(i = 0; i < (o.length / 2 - 1) * 4; i++) {
			// Add vertex
			ivert = Math.floor((i + 2) / 4);
			vertices.push(o[2 * ivert])
			vertices.push(o[2 * ivert + 1])
		}

		for(i = 0; i < (o.length / 2 - 1) * 4; i++) {
			// Find normal vector
			ibeg = Math.floor(i / 4);
			iend = ibeg + 1
			dx = o[2 * iend] - o[2 * ibeg];
			dy = o[2 * iend + 1] - o[2 * ibeg + 1];
			scale = (dx * dx + dy * dy) ** 0.5
			vertices.push(-dy / scale * (-1) ** i)
			vertices.push(dx / scale * (-1) ** i)
		}
		return new Float32Array(vertices);
	}

	function Path(path){
		this.path = path;
		this.p = path;
		this.size = 1;
		this.off = 0;

		if(typeof path==="string"){
			this.path = path;
			this.p = path.match(/[A-Za-z][^A-Za-z]*/g)
			for(var i = 0; i < this.p.length; i++){
				bits = [];
				this.p[i].replace(/ $/,"").replace(/^([A-Za-z]) ?(.*)$/,function(m,p1,p2){ bits = [p1,p2]; return ""; });
				this.p[i] = bits;
				if(this.p[i][1]){
					this.p[i] = [this.p[i][0]].concat(this.p[i][1].split(/ /));
					for(var j = 1; j < this.p[i].length; j++){
						this.p[i][j] = this.p[i][j].split(/\,/);
						for(var k = 0; k < this.p[i][j].length; k++) this.p[i][j][k] = parseFloat(this.p[i][j][k]);
					}
				}else this.p[i].splice(1,1);
			}
		}
		this.setOrigin = function(x,y){
			this.o = {'x':x,'y':y};
			return this;
		}
		this.setSize = function(s){
			this.size = s;
			return this;
		}
		this.draw = function(ctx){
			let x = 0;
			let y = 0;
			let first;
			let t = "";
			var size = this.size;
			// Change origin
			if(this.o){
				x = this.o.x;
				y = this.o.y;
				ctx.moveTo(x,y);
			}
			for(var i = 0; i < this.p.length; i++){
				t = this.p[i][0];
				uc = (this.p[i][0]==this.p[i][0].toUpperCase());
				if(this.p[i].length > 1){
					for(var j = 1; j < this.p[i].length; j++){
						if(t=="m" || t=="l"){ x += this.p[i][j][0]*size; y += this.p[i][j][1]*size; }
						else if(t=="M" || t=="L"){ x = this.p[i][j][0]*0.5*size + this.o.x; y = this.p[i][j][1]*0.5*size + this.o.y; }
						else if(t=="h") x += this.p[i][j][0]*size;
						else if(t=="H") x = this.p[i][j][0]*0.5*size + this.o.x;
						else if(t=="v") y += this.p[i][j][0]*size;
						else if(t=="V") y = this.p[i][j][0]*0.5*size + this.o.y;
						
						if(t.toLowerCase()=="m") ctx.moveTo(x,y);
						else ctx.lineTo(x,y);
						if(!first) first = {'x':x,'y':y};
					}
				}else{
					if(t=="Z") ctx.lineTo(first.x,first.y);
				}
			}
			return this;
		}
		this.toString = function(){
			var str = '';
			var size = this.size;
			for(var i = 0; i < this.p.length; i++){
				str += (i>0 ? ' ':'')+this.p[i][0];
				uc = (this.p[i][0]==this.p[i][0].toUpperCase());
				for(var j = 1; j < this.p[i].length; j++){
					str += ' ';
					if(typeof this.p[i][j]==="number") str += this.p[i][j]*(uc ? 0.5 : 1)*size+(uc ? this.o.x : 0);
					else{
						for(var k = 0; k < this.p[i][j].length; k++){
							if(k > 0) str += ',';
							if(typeof this.p[i][j][k]=="number") str += this.p[i][j][k]*(uc ? 0.5 : 1)*size+(uc ? this.o.x : 0);
						}
					}
				}
			}
			if(this.o) str = 'M '+this.o.x+' '+this.o.y+' '+str;
			return str;
		}
		this.svg = function(attr){
			if(!attr) attr = {};
			if(!attr.width) attr.width = 32;
			if(!attr.height) attr.height = 32;
			var svg = '<svg width="'+attr.width+'" height="'+attr.height+'"	viewBox="0 0 '+attr.width+' '+attr.height+'" xmlns="http://www.w3.org/2000/svg">';
			svg += '<path d="'+this.toString()+'" fill="'+attr.fillStyle+'" stroke="'+attr.strokeStyle+'" stroke-width="'+attr.strokeWidth+'">'
			svg += '</svg>';
			return svg;
		}
		return this;
	}


	function toPowerTwo(n){
		return Math.pow(2,Math.ceil(Math.log2(n)/Math.log2(2)));
	}


	function Icon(shape,attr){

		function setWH(p,w,h,s){
			p.width = w;
			p.height = h;
			p.scale = s;
			p.c.width = Math.round(w*s);
			p.c.height = Math.round(h*s);
			p.ctx = p.c.getContext('2d');
			p.ctx.scale(s,s);
			return p;
		}
		
		if(!attr) attr = {};
		attr.strokeWidth = (attr.strokeWidth || 0);
		let paper = { 'c': document.createElement('canvas') };
		let s2 = (attr.size+attr.strokeWidth*2);
		let w = attr.width || s2;
		let h = attr.height || s2;
		// Set properties of the temporary canvas
		paper = setWH(paper,w,h,window.devicePixelRatio);
		paper.ctx.clearRect(0,0,w,h);
		paper.ctx.fillStyle = attr.fillStyle;
		if(attr.strokeWidth) paper.ctx.strokeStyle = attr.strokeStyle;
		paper.ctx.lineWidth = attr.strokeWidth;
		paper.ctx.lineCap = "square";
		if(shape!="stroke") paper.ctx.beginPath();

		let cx = (w/2);
		let cy = (h/2);
		let dw = attr.size/2;
		let path;

		// https://vega.github.io/vega/docs/marks/symbol/
		if(shape=="circle"){
			paper.ctx.arc(cx,cy,(dw || 4),0,Math.PI*2,false);
			paper.ctx.fill();
			if(attr.strokeWidth) paper.ctx.stroke();
			path = 'm -'+(dw||4)+',0 a '+(dw||4)+' '+(dw||4)+' 0 1 0 '+((dw||4)*2)+' 0 a '+(dw||4)+' '+(dw||4)+' 0 1 0 -'+((dw||4)*2)+' 0';
		}else if(shape=="square") path = "m-0.5,0.5 l 1,0 0,-1 -1,0 Z";
		else if(shape=="cross") path = "m-0.2,0.2 h -0.3 v -0.4 h 0.3 v -0.3 h 0.4 v 0.3 h 0.3 v 0.4 h-0.3 v 0.3 h -0.4Z";
		else if(shape=="diamond") path = 'm0,0.5l0.5,-0.5 -0.5,-0.5 -0.5,0.5 Z';
		else if(shape=="triangle-up" || shape=="triangle") path = 'm-0.5,0.4330127 l 1,0 -0.5,-0.8660254 Z';
		else if(shape=="triangle-down") path = 'm-0.5,-0.4330127 l 1,0 -0.5,0.8660254 Z';
		else if(shape=="triangle-right") path = 'm-0.4330127,0.5 l0,-1 0.8660254,0.5Z';
		else if(shape=="triangle-left") path = 'm0.4330127,0.5 l0,-1 -0.8660254,0.5Z';
		else if(shape=="arrow") path = 'm-0.1,0.5 l 0,-0.5 -0.15,0 0.25,-0.5 0.25,0.5 -0.15,0 0,0.5 Z';
		else if(shape=="wedge") path = 'm-0.25,0.4330127 l 0.5,0 -0.25,-0.8660254 Z';
		else if(shape=="stroke") path = 'm-0.5,0 l 1,0';
		else if(shape=="hexagram") path = 'm-0.1666667,0.2886751 l 0.1666667,0.2886751 0.1666667,-0.2886751 0.333333,0 -0.1666667,-0.2886751 0.1666667,-0.2886751 -0.333333,0 -0.1666667,-0.2886751 -0.1666667,0.2886751 -0.333333,0 0.1666667,0.2886751 -0.1666667,0.2886751 Z';
		else path = shape;
		path = (new Path(path));
		path.setOrigin(cx,cy);
		if(shape!="circle"){
			path.setSize(attr.size);
			path.draw(paper.ctx);
			if(shape!="stroke") paper.ctx.fill();
			if(attr.strokeWidth) paper.ctx.stroke();
		}
		if(attr.output == "texture") return paper.ctx.getImageData(0, 0, s2, s2);
		else if(attr.output == "svg") return path.svg(attr);
		else return paper.c;
	}

	function setRange(x1,y1,x2,y2){
		w = x2 - x1;
		h = y2 - y1;
		currentScale = [w,h];
		currentTranslation = [-x1,-y1];
		drawScene();
	}
	
	function compileShader(gl, typ, attr){
		let type = (typ=="vertex") ? gl.VERTEX_SHADER : gl.FRAGMENT_SHADER;
		let code = attr.src;
		let shader = gl.createShader(type);
		gl.shaderSource(shader, code+'');
		gl.compileShader(shader);
		if(!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
			console.log(`Error compiling ${typ} shader:`);
			console.log(gl.getShaderInfoLog(shader));
		}
		return shader;
	}

	</script>
	
	<div class="holder">
		<canvas id="canvas" width="800" height="460">
			Oh no! Your browser doesn't support canvas!
		</canvas>
		
	</div>

</body>
</html>