<html>
<head>

	<script src="stuquery.min.js"></script>
	
	<script>
	
	
	var paper;
	var G = {};
	G.deepExtend = function(out){
		out = out || {};
		for(var i = 1; i < arguments.length; i++){
			var obj = arguments[i];
			if(!obj) continue;

			for(var key in obj){
				if(obj.hasOwnProperty(key)){
					if(typeof obj[key] === 'object') out[key] = G.deepExtend(out[key], obj[key]);
					else out[key] = obj[key];
				}
			}
		}
		return out;
	};
	G.extend = function(out){
		out = out || {};
		for(var i = 1; i < arguments.length; i++){
			if(!arguments[i]) continue;
			for(var key in arguments[i]){
				if (arguments[i].hasOwnProperty(key)) out[key] = arguments[i][key];
			}
		}
		return out;
	};
	/**
	 * @desc Make a copy of the object (to avoid over-writing it)
	 */
	function clone(a){ return JSON.parse(JSON.stringify(a)); }
	/**
	 * @desc Define a shortcut for checking variable types
	 */
	function is(a,b){ return (typeof a == b) ? true : false; }

	function distanceFromLine(p,a,b){
		return Math.sqrt(SqDistancePtSegment(p,a,b));
	}
	
	function SqDistancePtSegment(p,a,b){
		function Dot(p1,p2){ return (p1.x*p2.x + p1.y*p2.y); }

		var n = { 'x': b.x - a.x, 'y': b.y - a.y };
		var pa = { 'x': a.x - p.x, 'y': a.y - p.y };

		var c = Dot(n,pa);

		// Closest point is a
		if(c > 0.0 || (n.x==0 && n.y==0)) return Dot(pa,pa);

		var bp = { 'x':p.x - b.x, 'y':p.y - b.y };

		// Closest point is b
		if(Dot(n,bp) > 0.0) return Dot(bp,bp);

		// Closest point is between a and b
		var f = (c / Dot(n,n));
		var e = {'x':pa.x - n.x * f, 'y': pa.y - n.y*f };

		return Dot(e,e);
	}

	function Paper(attr){
		if(!attr) attr = {};
		var c, events = {};
		// Get an existing element if it exists
		if(attr.el && attr.el.tagName=="CANVAS") c = attr.el;
		if(attr.id && document.getElementById(attr.id).tagName=="CANVAS") c = document.getElementById(attr.id);
		if(!c) c = document.createElement('canvas');

		w = attr.width||c.clientWidth;
		h = attr.height||c.clientHeight;
		s = attr.devicePixelRatio||window.devicePixelRatio;


		/**
		 * @desc Attach a handler to an event for the Canvas object
		 * @usage canvas.on(eventType[,eventData],handler(eventObject));
		 * @usage canvas.on("resize",function(e){ console.log(e); });
		 * @usage canvas.on("resize",{me:this},function(e){ console.log(e.data.me); });
		 * @param {string} ev - the event type
		 * @param {object} e - any properties to add to the output as e.data
		 * @param {function} fn - a callback function
		 */
		this.on = function(ev,e,fn){
			if(typeof ev!="string") return this;
			if(is(fn,"undefined")){
				fn = e;
				e = {};
			}else{
				e = {data:e};
			}
			if(typeof e!="object" || typeof fn!="function") return this;
			if(events[ev]) events[ev].push({e:e,fn:fn});
			else events[ev] = [{e:e,fn:fn}];
			return this;
		};
		this.width = function(wide){
			if(typeof wide==="number"){
				w = wide;
				c.width = (s==1 ? w : Math.round(w*s));
			}
			return w;
		}
		this.height = function(tall){
			if(typeof tall==="number"){
				h = tall;
				c.height = (s==1 ? h : Math.round(h*s));
			}
			return h;
		}
		this.resize = function(wide,tall){
			if(wide == w && tall == h) return this;
			this.width(wide);
			this.height(tall);
			trigger(this,"resize",{width:w,height:h});
			return this;
		}


		this.ctx = c.getContext(attr.getContext||'2d');
		this.ctx.scale(s,s);
		this.width(w);
		this.height(h);

		/**
		 * @desc Trigger a defined event with arguments. This is for internal-use.
		 */
		function trigger(me,ev,args){
			if(!me) return;
			if(typeof ev != "string") return;
			if(typeof args != "object") args = {};
			var o = [];
			if(typeof events[ev]=="object"){
				for(var i = 0 ; i < events[ev].length ; i++){
					var e = args||{};
					e = G.deepExtend(e,events[ev][i].e);
					if(typeof events[ev][i].fn == "function") o.push(events[ev][i].fn.call(me,e));
				}
			}
			if(o.length > 0) return o;
		};

		function getMousePosition(e) {
			e = e || window.event;
			if(!e) return {};

			var target = e.originalEvent.target || e.originalEvent.srcElement,
			style = target.currentStyle || window.getComputedStyle(target, null),
			borderX = parseInt(style['borderLeftWidth'], 10),
			borderY = parseInt(style['borderTopWidth'], 10),
			rect = target.getBoundingClientRect();
			e.x = e.originalEvent.clientX - borderX - rect.left,
			e.y = e.originalEvent.clientY - borderY - rect.top;

			return e;
		}


		// Add event callbacks
		var _obj = this;
		var olddist = null;
		var lastevent = null;
		S(c).on("mousedown",function(e){ e.stuart = true; trigger(_obj,"mousedown",e); })
			.on("mousemove",function(e){ e = getMousePosition(e); trigger(_obj,"mousemove",e); })
			.on("mouseup",function(e){ trigger(_obj,"mouseup",e); })
			.on("mouseover",function(e){ trigger(_obj,"mouseover",e); })
			.on("mouseleave",function(e){ trigger(_obj,"mouseleave",e); })
			.on("wheel",function(e){ e = getMousePosition(e); trigger(_obj,"wheel",e); })
			.on("touchstart",function(e){
				var ev = e.originalEvent;
				ev.preventDefault();
				olddist = null;
				var touches = ev.touches;
				if(touches && touches.length==1){
					// One touch maps to pan (mousedown)
					e.originalEvent = updateEvent(e,touches);
					e.originalEvent.which = 1;
					trigger(_obj,"mousedown",e);
					trigger(_obj,"mouseover",e);
				}
			}).on("touchmove",function(e){
				e.originalEvent.preventDefault();
				var touches = e.originalEvent.touches;

				var m = (touches ? touches.length:0);

				// Keep a copy of the event for the touchend event
				lastevent = e.originalEvent;
				if(typeof _obj.updating!=="boolean") _obj.updating = false;
				if(!_obj.updating && m > 0){
					if(m == 1){
						e.x = touches[0].pageX - e.originalEvent.target.offsetLeft;
						e.y = touches[0].pageY - e.originalEvent.target.offsetTop;
						// One touch maps to pan (mousemove)
						e.originalEvent.which = 1;
						trigger(_obj,"mousemove",e);
					}else if(m == 2){
						var dist = Math.hypot(touches[0].pageX - touches[1].pageX, touches[0].pageY - touches[1].pageY);
						e.x = (touches[0].pageX + touches[1].pageX)/2 - e.originalEvent.target.offsetLeft;
						e.y = (touches[0].pageY + touches[1].pageY)/2 - e.originalEvent.target.offsetTop;
						// Multi-touch maps to zoom (wheel)
						e.originalEvent.deltaY = (olddist ? (dist > olddist ? -1 : 1):-1);
						if(Math.abs(dist-olddist) > 4){
							e.speed = 0.95;
							e.update = false;
							trigger(_obj,"wheel",e);
							olddist = dist;
						}
					}
				}
			}).on("touchend",{me:this}, function(e){
				var ev = e.originalEvent;
				ev.preventDefault();
				var touches = ev.touches;
				if(touches){
					// One touch maps to pan (mousedown)
					if(touches.length > 0) e.originalEvent = updateEvent(e,touches);
					e.originalEvent.which = 1;
				}else e = lastevent;
				trigger(_obj,"mouseup",e);
			});

		return this;
	}

	
	S().ready(function(){

		var n = 1e5;
		var layers = [];
		var start = new Date();

		var stime = 1572969167343;
		
		createLayers();

		paper = new Paper({'el':document.getElementById('display')});

		paper.ctx.fillStyle = 'green';
		paper.ctx.lineWidth = 5;

		function log(nm,dt,m,s){
			var con = S('#console');
			con.append('<span style="font-weight: bold;">Finder:</span> '+dt+'ms for '+s+'<br />');
			con[0].scrollTop = con[0].scrollHeight;
		}

		function createLayers(){
			var start = new Date();
			layers = [];
			var rects = new Array(n);
			var lines = new Array(n);
			for(var i = 0; i < n; i++){
				x = stime + i*15/n;
				y = Math.sin(x);
				dy = 0.15*Math.max(0.5,Math.random());
				rects[i] = {'x': x,'y1':y-dy,'y2':y+dy,'type':'rect','strokeWidth':4};
				lines[i] = {'x': x,'y':y,'type':'line','strokeWidth':4};
			}
			layers.push({'rects':rects});
			layers.push({'rects':lines});
			layers.push({'rects':[{'x':stime+2,'type':'rule','strokeWidth':4}]});
			var now = new Date();
			S('#console').append('<span style="font-weight: bold;">Startup:</span> <em>'+(now-start)+'</em>ms<br />');
			S('#console').append('<span style="font-weight: bold;">Processing:</span> <em>'+n+'</em> rectangles<br />');


		}


		function Finder(){
		
			var idx,min,i,start,now,m;
			function rectanglesIntersect(a,b){
				var aLeftOfB = a.x2 < b.x1;
				var aRightOfB = a.x1 > b.x2;
				var aAboveB = a.y1 > b.y2;
				var aBelowB = a.y2 < b.y1;
				return !(aLeftOfB || aRightOfB || aAboveB || aBelowB);
			}
			function convertToScreen(v){
				return { 'x': (v.x-xmin)*xconv + pad, 'y': (v.y-ymin)*yconv + pad };
			}
			function matches(ls,p,padding){
				m = [];
				idx = -1;
				var rs,l,x,w,y,h,dv,a,b,ok;
				for(l = 0; l < ls.length; l++){
					isrect = false;
					rs = ls[l].rects;
					t = rs[0].type;
					if(t=="rect" && (typeof rs[0].x==="number" || typeof rs[0].y==="number")) t = "rectline";
					if(t=="rule") t = "rectline";

					if(t=="line"){
						ok = false;
						var min = 1e100;
						var a = convertToScreen(rs[0]);
						dv = ((rs[0].strokeWidth/2)||2)+padding;
						for(i = 1; i < rs.length; i++){
							b = convertToScreen(rs[i]);
							d = distanceFromLine(p.screen,a,b);
							min = Math.min(d,min);
							a = b;
						}
						if(min < dv) m.push({'layer':l,'id':'*'});
					}else{
						for(i = 0; i < rs.length; i++){
							ok = false;
							dv = ((rs[i].strokeWidth/2)||2)+padding;
							if(t=="rect"){
								if(p.data.x >= rs[i].x1 && p.data.x <= rs[i].x2 && p.data.y >= rs[i].y1 && p.data.y <= rs[i].y2) ok = true;
							}else if(t=="rectline"){
								if(typeof rs[i].x==="number"){
									x = (rs[i].x-xmin)*xconv + pad;
									if(p.screen.x >= x-dv && p.screen.x <= x+dv){
										if(typeof rs[i].y1==="number"){
											a = (rs[i].y1-ymin)*yconv + pad;
											b = (rs[i].y2-ymin)*yconv + pad;
											if(p.screen.y >= a-dv && p.screen.y <= b+dv) ok = true;
										}else ok = true;
									}
								}
								if(typeof rs[i].y==="number"){
									y = (rs[i].y-ymin)*yconv + pad;
									if(p.screen.y >= y-dv && p.screen.y <= y+dv){
										if(typeof rs[i].x1==="number"){
											a = (rs[i].x1-xmin)*xconv + pad;
											b = (rs[i].x2-xmin)*xconv + pad;
											if(p.screen.x >= a-padding && p.screen.x <= b+padding) ok = false;
										}else ok = true;
									}
								}
							}else if(t=="symbol"){
							
							}

							if(ok) m.push({'layer':l,'id':i});

						}
					}
				}
				return m;		
			}
			function nearestX(r,p,tolerance){
				min = 1e100;
				idx = -1;
				for(i = 0; i < r.length; i++){
					dx = Math.abs(((r[i].x1+r[i].x2)/2) - p.data.x);
					if(dx < min){
						idx = i;
						min = dx;
					}
				}
				if(min < tolerance) return [{'layer':0,'id':idx}];
				else return [];
			}
			function within(r,p,tolerance){
				var j;
				var match = [];
				m = [];
				if(typeof tolerance.x!=="number") return m;

				var bbox = {'x1':p.data.x-tolerance.x,'x2':p.data.x+tolerance.x,'y1':p.data.y-tolerance.y,'y2':p.data.y+tolerance.y};
console.log(bbox,tolerance.x)
				for(i = 0; i < r.length; i++){
					if(rectanglesIntersect(r[i],bbox)) m.push({'layer':0,'id':i});
				}
				return m;
			}

			this.getMatches = function(r,p,padding){
				start = new Date();
				m = matches(r,p,padding||0);
				now = new Date();
				log('Finder',(now-start),m,'getMatches ('+m.length+' match'+(m.length==1?'':'es')+')');
				return m;
			}

			this.getNearestX = function(r,p,tolerance){
				start = new Date();
				m = nearestX(r,p,tolerance.x);
				now = new Date();
				log('Finder',(now-start),m,'getNearestX ('+m.length+' match'+(m.length==1?'':'es')+')');
				return m;
			}

			this.getWithin = function(r,p,tolerance){
				start = new Date();
				m = within(r,p,tolerance);
				now = new Date();
				log('Finder',(now-start),m,'getWithin ('+m.length+' match'+(m.length==1?'':'es')+')');
				return m;
			}

			return this;
		}
	
		finder = new Finder();



		width = S('#display')[0].clientWidth;
		height = S('#display')[0].clientHeight;


		pad = 20;
		xmin = 1e100;
		xmax = -1e100;
		ymin = 1e100;
		ymax = -1e100;
		method = "matches";
		for(var l = 0; l < layers.length; l++){
			for(var i = 0; i < layers[l].rects.length; i++){
				if(typeof layers[l].rects[i].x1==="number"){
					xmin = Math.min(layers[l].rects[i].x1,xmin);
				}
				if(typeof layers[l].rects[i].x2==="number"){
					xmax = Math.max(layers[l].rects[i].x2,xmax);
				}
				if(typeof layers[l].rects[i].y1==="number"){
					ymin = Math.min(layers[l].rects[i].y1,ymin);
				}
				if(typeof layers[l].rects[i].y2==="number"){
					ymax = Math.max(layers[l].rects[i].y2,ymax);
				}
				if(typeof layers[l].rects[i].x==="number"){
					xmin = Math.min(layers[l].rects[i].x,xmin);
					xmax = Math.max(layers[l].rects[i].x,xmax);
				}
				if(typeof layers[l].rects[i].y==="number"){
					ymin = Math.min(layers[l].rects[i].y,ymin);
					ymax = Math.max(layers[l].rects[i].y,ymax);
				}
			}
		}
		xconv = (width-pad*2)/(xmax-xmin);
		yconv = (height-pad*2)/(ymax-ymin);

		function getCursorCoords(x,y){
			var o = {'screen':{'x':x,'y':height-y}};
			x = xmin + (o.screen.x-pad)/xconv;
			y = ymin + (o.screen.y-pad)/yconv;
			o.data = {'x':x,'y':y};
			return o;
		}
		
		paper.on('mousemove',function(e){
			pt = getCursorCoords(e.x,e.y);
			//console.log('screen',pt.screen,'data',pt.data);
			getRects(pt);
		}).on('touchmove',function(e){
			var touches = e.originalEvent.changedTouches;
			for(var i = 0; i < touches.length; i++) {
				log("Touchstart",0,[],""+i+"..."+touches[i].pageX+','+touches[i].pageY);
			}
			pt = getCursorCoords(touches[0].pageX,touches[0].pageY);
			getRects(pt);
		});


		function drawRects(match){

			var start = new Date();
			var height = paper.height();
			var width = paper.width();
			var l,i,j,iplus,highlight,colour,x,y,dw,dh,drawn;

			drawn = 0;
			paper.ctx.clearRect(0,0,width,height);

			for(l = 0; l < layers.length; l++){

				iplus = (layers[l].rects.length > 100) ? Math.max(Math.round(layers[l].rects.length/100),1) : 1;

				for(i = 0; i < layers[l].rects.length; i+=iplus){

					highlight = false;
					for(j = 0; j < match.length; j++){
						if(match[j].layer==l && (match[j].id==i||match[j].id=="*")) highlight = true;
					}
					
					colour = (highlight ? 'rgba(255,200,0,0.8)' : 'rgba(0,200,0,0.5)');

					if(layers[l].rects[i].type=="rect"){
						paper.ctx.fillStyle = colour;
						if(typeof layers[l].rects[i].x1!=="number"){
							if(typeof layers[l].rects[i].x==="number"){
								dw = layers[l].rects[i].strokeWidth||2;
								x = (layers[l].rects[i].x-xmin)*xconv - dw/2 + pad;
							}else{
								x = pad;
								dw = w-pad*2;
							}
						}else{
							x = (layers[l].rects[i].x1-xmin)*xconv + pad;
							dw = Math.round(Math.abs(layers[l].rects[i].x2-layers[l].rects[i].x1)*xconv);
						}

						if(typeof layers[l].rects[i].y1!=="number"){
							if(typeof layers[l].rects[i].y==="number"){
								dh = layers[l].rects[i].strokeWidth||2;
								y = (layers[l].rects[i].y-ymin)*yconv + dh/2;
							}else{
								y = pad;
								dh = h-pad*2;
							}
						}else{
							y = pad + (layers[l].rects[i].y1-ymin)*yconv;
							dh = Math.round((layers[l].rects[i].y2-layers[l].rects[i].y1)*yconv);
						}
						y = height - y - dh;
						if(dh > 0 && dw > 0){
							paper.ctx.fillRect(x,y,dw,dh);
							drawn++;
						}
					}else if(layers[l].rects[i].type=="line"){
						paper.ctx.strokeStyle = colour;
						if(typeof layers[l].rects[i].x==="number") x = (layers[l].rects[i].x-xmin)*xconv + pad;
						if(typeof layers[l].rects[i].y==="number") y = h - ((layers[l].rects[i].y-ymin)*yconv + pad);

						if(i==0) paper.ctx.moveTo(x,y);
						else paper.ctx.lineTo(x,y);

						drawn++;
					}
				}
			}
			paper.ctx.stroke();
			now = new Date();
		}
		
		pt = { x: 1572969167352.5, y: 1 };

		S('#nearestx').on('click',function(){ method = "nearestx"; getRects(); });
		S('#matches').on('click',function(){ method = "matches"; getRects(); });
		S('#matchesfuzzy').on('click',function(){ method = "matchesfuzzy"; getRects(); });
		S('#within').on('click',function(){ method = "within"; getRects(); });
		S('.n').on('click',function(e){ n = parseInt(e.currentTarget.getAttribute('data')); createLayers(); drawRects([]) })
		
		function getRects(p){
			var near = [];
			if(p){
				if(method == "nearestx") near = finder.getNearestX(rects,p,{'x':1});
				else if(method == "matches") near = finder.getMatches(layers,p);
				else if(method == "matchesfuzzy") near = finder.getMatches(layers,p,5);
				else if(method == "within") near = finder.getWithin(rects,p,{'x':2,'y':0.25});
			}
			drawRects(near);
		}
		drawRects([]);
		
	});

	</script>
	<style>
	* { box-sizing: border-box; }
	body { padding: 0px; margin: 0px; font-size: 16px; font-family: Helvetica, Arial, sans-serif; }
	#console { position: absolute; bottom: 0px; left: 0px; width: 100%; border-top: 1px solid black; padding: 0.5em; background: #fbfbfb; max-height: 150px; overflow-y: auto; }
	#controls { top: 0px; left: 0px; width: 100%; padding: 0.5em; background: #fbfbfb; border-bottom: 1px solid black; }
	#display { margin: 0.5em; width: 800px; height: 500px; border: 15px solid red; }
	button { line-height: 1.5em; font-size: 1em; }
	</style>
</head>
<body>

	<div id="controls">
		<button id="nearestx">Nearest X</button>
		<button id="matches">Matches</button>
		<button id="matchesfuzzy">Matches (within 5px)</button>
		<button id="within">Within</button>
		<br />Line segments/rects:
		<button class="n" data="10000">1e4</button>
		<button class="n" data="100000">1e5</button>
		<button class="n" data="1000000">1e6</button>
	</div>	
	<div id="console"></div>
	<div style="padding:50px;">
		<div style="border:10px solid black;">
			<canvas id="display"></canvas>
		</div>
	</div>

</body>
</html>